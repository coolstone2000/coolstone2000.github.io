---
layout: single
title: "Operating sysetem - Virtualization_processes"
categories: Operating_system
tags: OS
toc: true
author_profile: false
---

# Limited Direct Execution (제한적 직접 실행 원리)

앞에서 계속 말했듯 CPU를 가상화 하기 위해 물리적인 CPU를 공유하여 여러 작업들이 동시에 실행되는 것 처럼 보이게 한다. 이것은 한 프로세스를 잠시동안 실행하고 또 다른 프로세스를 또 잠깐 실행하여 이를 반복하여 가상화를 하게 된다. 아마 이런 느낌....
<center><img src="/images/OS/pro_onepunch.png"></center>
그러나 이런 가상화를 구현하기 위해서는 몇가지 문제를 해결해야 한다.
1. 성능 저하 -> 시스템에 과부화를 주지 않고 가상화를 어떻게 구현할까?
2. 제어 문제 -> 프로세스를 효율적으로 실행시킬 수 있는 방법은 무엇일까? (특히 중요하다!)

## 기본 원리: 제한적 직접 실행

운영체제 개발자들은 프로그램을 빠르게 실행하기 위해 제한적 직접 실행(Limited Direct Execution)이라는 기법을 고안했다. "직접 실행"은 CPU에서 직접 실행시킨다는 뜻이다. 즉, 프로그램을 프로세서에 올리고 데이터와 변수,코드를 가져와 메모리에 저장하고 시작점으로 분기해 코드를 실행한다.
<center><img src="/images/OS/pro_de.png"></center>
이것은 제한 없는 직접 실행 프로토콜이다. 이 제한 없는 직접 실행은 문제를 일으킨다. 첫 번째 문제는 프로그램과 운영체제가 원치않는 일을 하지 않는 것을 보장할 수 없다는 것이고 두 번째 문제는 프로세스 실행 시 운영체제는 프로그램의 실행을 중단하고 다른 프로세스로 전환 시킬 수 없다는 것이다. 즉, 시분할(time sharing)을 어떻게 할 것이냐이다.

## 문제점 1: 제한된 연산

직접 실행을 하면 굉장히 빠르다는 장점이 있다. 하지만 이렇게 되면 문제가 있다. 프로세스가 특수한 종류의 연산(ex. convolution, GCD, LCM ....)을 요구하면 디스크의 입출력 요청이나 시스템 자원들에 대한 추가 할당 요청을 해야하는 등 CPU 자체에서만 해결이 되지 않는 문제가 있다. <br>
파일에 대한 접근을 허용하기 전에 접근 권한을 검사하는 파일 시스템을 구현한다고 하자. 우선 프로세스가 디스크에 대해 입출력 하는 것을 제한하지 않으면 권한을 검사하는 기능이 아무런 의미가 없을 것이다. 그래서 **사용자 모드(user mode)**라는 것이 도입되었다. 사용자 모드에서는 할 수 있는 일이 제한된다. 만약 허용되지 않은 입출력 요청을 하면 운영체제는 해당 프로세스를 제거한다. 이와 대비되는 모드로는 커널 모드(kernel mode)가 있다. 운영체제의 중요한 코드들이 실행되며 모든 작업을 수행할 수 있다.<br>
만약 사용자 모드에 있을 때 특권 명령어를 실행해야 하면 어떻게 해야할까? 이런 제한 작업에 대한 실행을 허용하기 위해 거의 모든 현대 하드웨어는 사용자 프로세스에게 **시스템 콜(system call)**을 제공한다. 이런 시스템 콜의 기능에는 파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당 등이 있다.<br>
시스템 콜을 실행 하기 위해서는 trap 특수 명령어를 실행해야 한다. 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 시켜 프로세스가 모든 명령어를 처리할 수 있다. 완료되면 운영체제는 return-from-trap 명령어를 호출한다. 이 명령어는 다시 사용자 모드로 되 돌려준다. 하드웨어는 trap 명령어를 수행할 때 호출한 프로세스의 필요한 레지스터들을 저장해야한다. 왜냐하면 return-from-trap 명령어를 통해 사용자 프로세스로 다시 리턴할 수 있도록 하기 위함이다.<br>
- - -
x86에서는 프로그램 카운터, 플래그와 다른 몇개의 레지스터를 각 프로세스의 **커널 스택(kernel stack)**에 저장한다. return-from-trap 명령어는 이 값의 스택을 팝(pop)시켜 사용자 모드 프로그램의 실행을 다시 시작한다.
<center><img src="/images/OS/pro_pop.png"></center><br>
trap이 운영체제 코드의 어디를 실행할 지는 모른다는 문제가 있다. 호출한 프로세서는 주소를 명시할 수 없다. 왜냐하면 커널 내부의 원하는 지점을 접근할 수 있다는 것이기 때문에 위험하다. 그래서 커널이 임의의 코드를 실행하기 위해서는 접근 권한 검사가 끝난 후에 분기해야 한다. 
- - - 
커널은 부팅 시에 **트랩 테이블(trap table)**을 만들고 이를 이용하여시스템을 통제한다. 컴퓨터가 부트될 때는 커널 모드에서 동작하기 때문에 하드웨어를 원하는대로 통제할 수 있다. 하드웨어에게 예외사건이 일어났을 때 운영체제가 어디로 분기할 지 알려준다. 이 역할을 **트랩 핸들러(trap handler)**가 한다. 하드웨어는 이 정보로 해당 위치를 기억하고 있다. 트랩 테이블은 트랩 핸들러의 주소를 저장하고 있다. 어떠한 예외가 들어 왔을때 어디를 실행하라는 것을 명시하고 있는 것은 트랩 핸들러이다. 그렇기 때문에 이것은 커널에서 이루어져야 하며 하드웨어에 주소를 저장해 둬야 한다. <br>
***트랩 테이블은 trap Exeption에 대한 트랩 핸들러들의 주소과 보관된 테이블이다. (운영체제 개발자가 이 handler 함수를 디자인한다.) 트랩 테이블은 부팅시 CPU에 저장된다.***
<center><img src="/images/OS/pro_lde.png"></center><br>
LED 프로토콜은 두 단계로 진행된다. **부팅**과 **실행**이다. 부팅에서는 항상 커널 모드이고 항상 트랩 테이블을 초기화하고 하드웨어(CPU)는 이 테이블의 위치를 기억해둔다. 그리고 실행 시작할 때는 몇 가지 사전 작업을 한 후 return-from-trap을 이용해 사용자 모드로 전환하여 프로세스를 실행한다. 그러다 프로세스가 시스템 콜을 하면 트랩하여 커널 모드로 전환 돼 시스템 콜의 임무를 수행 한 후 다시 return-from-trap을 통해 프로세스로 돌아간다. 프로세스가 끝나면 return을 하면서 종료를 하는데 이 것은 또 커널 모드로 가야 하기 때문에 trap을 통해 운영체제에서 정리작업을 통해 모든 일을 완료 시킨다.

## 문제점 2: 프로세스 간 전환
